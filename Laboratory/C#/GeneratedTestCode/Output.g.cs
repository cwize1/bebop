//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:0.0.1-20210208-0337
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using global::System.Collections.Immutable;
using global::System.Linq;
using global::System;
using global::Bebop.Attributes;
using global::Bebop.Runtime;
using global::Bebop.Exceptions;
//
// This source code was auto-generated by bebopc, Version=0.0.1-20210208-0337.
//
namespace Bebop.Codegen {
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Enum)]
  public enum Instrument : uint {
    Sax = 0,
    Trumpet = 1,
    Clarinet = 2
  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct, true)]
  public abstract class BaseMusician : System.IEquatable<BaseMusician> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Name { get; init; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public Instrument Plays { get; init; }

    public bool Equals(BaseMusician other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Name == other.Name && Plays == other.Plays;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseMusician baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Name.GetHashCode();
      hash ^= Plays.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseMusician left, BaseMusician right) => Equals(left, right);
    public static bool operator !=(BaseMusician left, BaseMusician  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct, true)]
  public sealed class Musician : BaseMusician {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseMusician record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseMusician record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseMusician record, ref BebopWriter writer) {
      writer.WriteString(record.Name);
      writer.WriteEnum<Instrument>(record.Plays);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseMusician, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Musician Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Musician DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      Instrument field1;
      field1 = reader.ReadEnum<Instrument>();
      return new Musician {
        Name = field0,
        Plays = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseMusician, new() {
      string field0;
      field0 = reader.ReadString();
      Instrument field1;
      field1 = reader.ReadEnum<Instrument>();
      return new T {
        Name = field0,
        Plays = field1,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Message)]
  public abstract class BaseSong : System.IEquatable<BaseSong> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public string? Title { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public ushort? Year { get; set; }
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public BaseMusician[]? Performers { get; set; }
    #nullable disable

    public bool Equals(BaseSong other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Title == other.Title && Year == other.Year && (Performers is null ? other.Performers is null : other.Performers is not null && Performers.SequenceEqual(other.Performers));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseSong baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Title is not null) hash ^= Title.GetHashCode();
      if (Year is not null) hash ^= Year.Value.GetHashCode();
      if (Performers is not null) hash ^= Performers.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseSong left, BaseSong right) => Equals(left, right);
    public static bool operator !=(BaseSong left, BaseSong  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Message)]
  public sealed class Song : BaseSong {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseSong record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseSong record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseSong record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.Title is not null) {
        writer.WriteByte(1);
        writer.WriteString(record.Title);
      }

      if (record.Year is not null) {
        writer.WriteByte(2);
        writer.WriteUInt16(record.Year.Value);
      }

      if (record.Performers is not null) {
        writer.WriteByte(3);
        {
          var length0 = unchecked((uint)record.Performers.Length);
          writer.WriteUInt32(length0);
          for (var i0 = 0; i0 < length0; i0++) {
            Bebop.Codegen.Musician.EncodeInto(record.Performers[i0], ref writer);
          }
        }
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseSong, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Song Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Song DecodeFrom(ref BebopReader reader) {

      var record = new Song();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Title = reader.ReadString();
            break;
          case 2:
            record.Year = reader.ReadUInt16();
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Performers = new BaseMusician[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                BaseMusician x0;
                x0 = Bebop.Codegen.Musician.DecodeFrom(ref reader);
                record.Performers[i0] = x0;
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseSong, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.Title = reader.ReadString();
            break;
          case 2:
            record.Year = reader.ReadUInt16();
            break;
          case 3:
            {
              var length0 = unchecked((int)reader.ReadUInt32());
              record.Performers = new BaseMusician[length0];
              for (var i0 = 0; i0 < length0; i0++) {
                BaseMusician x0;
                x0 = Bebop.Codegen.Musician.DecodeFrom(ref reader);
                record.Performers[i0] = x0;
              }
            }
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseLibrary : System.IEquatable<BaseLibrary> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public System.Collections.Generic.Dictionary<System.Guid, BaseSong> Songs { get; set; }

    public bool Equals(BaseLibrary other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return (Songs is null ? other.Songs is null : other.Songs is not null && Songs.SequenceEqual(other.Songs));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseLibrary baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Songs.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseLibrary left, BaseLibrary right) => Equals(left, right);
    public static bool operator !=(BaseLibrary left, BaseLibrary  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class Library : BaseLibrary {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseLibrary record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseLibrary record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseLibrary record, ref BebopWriter writer) {
      writer.WriteUInt32(unchecked((uint)record.Songs.Count));
      foreach (var kv0 in record.Songs) {
        writer.WriteGuid(kv0.Key);
        Bebop.Codegen.Song.EncodeInto(kv0.Value, ref writer);
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseLibrary, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Library Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Library DecodeFrom(ref BebopReader reader) {

      System.Collections.Generic.Dictionary<System.Guid, BaseSong> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<System.Guid, BaseSong>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BaseSong v0;
          k0 = reader.ReadGuid();
          v0 = Bebop.Codegen.Song.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new Library {
        Songs = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseLibrary, new() {
      System.Collections.Generic.Dictionary<System.Guid, BaseSong> field0;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field0 = new System.Collections.Generic.Dictionary<System.Guid, BaseSong>(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          System.Guid k0;
          BaseSong v0;
          k0 = reader.ReadGuid();
          v0 = Bebop.Codegen.Song.DecodeFrom(ref reader);
          field0.Add(k0, v0);
        }
      }
      return new T {
        Songs = field0,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Message)]
  public abstract class BaseA : System.IEquatable<BaseA> {
    #nullable enable
    [System.Diagnostics.CodeAnalysis.MaybeNull, System.Diagnostics.CodeAnalysis.AllowNull]
    public uint? A { get; set; }
    #nullable disable

    public bool Equals(BaseA other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return A == other.A;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseA baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      if (A is not null) hash ^= A.Value.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseA left, BaseA right) => Equals(left, right);
    public static bool operator !=(BaseA left, BaseA  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Message)]
  public sealed class A : BaseA {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseA record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseA record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseA record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      var start = writer.Length;

      if (record.A is not null) {
        writer.WriteByte(1);
        writer.WriteUInt32(record.A.Value);
      }
      writer.WriteByte(0);
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseA, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static A Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseA, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static A Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseA, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static A Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseA, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static A Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseA, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static A Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static A DecodeFrom(ref BebopReader reader) {

      var record = new A();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.A = reader.ReadUInt32();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseA, new() {
      var record = new T();
      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      while (true) {
        switch (reader.ReadByte()) {
          case 0:
            return record;
          case 1:
            record.A = reader.ReadUInt32();
            break;
          default:
            reader.Position = end;
            return record;
        }
      }
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseB : System.IEquatable<BaseB> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public bool B { get; set; }

    public bool Equals(BaseB other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return B == other.B;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseB baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= B.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseB left, BaseB right) => Equals(left, right);
    public static bool operator !=(BaseB left, BaseB  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class B : BaseB {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseB record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseB record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseB record, ref BebopWriter writer) {
      writer.WriteByte(record.B);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseB, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static B Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseB, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static B Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseB, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static B Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseB, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static B Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseB, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static B Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static B DecodeFrom(ref BebopReader reader) {

      bool field0;
      field0 = reader.ReadByte() != 0;
      return new B {
        B = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseB, new() {
      bool field0;
      field0 = reader.ReadByte() != 0;
      return new T {
        B = field0,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseC : System.IEquatable<BaseC> {

    public bool Equals(BaseC other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return true;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseC baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    public static bool operator ==(BaseC left, BaseC right) => Equals(left, right);
    public static bool operator !=(BaseC left, BaseC  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class C : BaseC {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseC record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseC record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseC record, ref BebopWriter writer) {

    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseC, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static C Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseC, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static C Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseC, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static C Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseC, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static C Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseC, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static C Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static C DecodeFrom(ref BebopReader reader) {

      return new C {
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseC, new() {
      return new T {
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseD : System.IEquatable<BaseD> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public string S { get; set; }

    public bool Equals(BaseD other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return S == other.S;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseD baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= S.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseD left, BaseD right) => Equals(left, right);
    public static bool operator !=(BaseD left, BaseD  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class D : BaseD {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseD record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseD record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseD record, ref BebopWriter writer) {
      writer.WriteString(record.S);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseD, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static D Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseD, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static D Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseD, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static D Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseD, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static D Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseD, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static D Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static D DecodeFrom(ref BebopReader reader) {

      string field0;
      field0 = reader.ReadString();
      return new D {
        S = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseD, new() {
      string field0;
      field0 = reader.ReadString();
      return new T {
        S = field0,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseX : System.IEquatable<BaseX> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public bool X { get; set; }

    public bool Equals(BaseX other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return X == other.X;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseX baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= X.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseX left, BaseX right) => Equals(left, right);
    public static bool operator !=(BaseX left, BaseX  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class X : BaseX {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseX record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseX record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseX record, ref BebopWriter writer) {
      writer.WriteByte(record.X);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseX, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static X Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseX, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static X Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseX, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static X Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseX, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static X Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseX, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static X Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static X DecodeFrom(ref BebopReader reader) {

      bool field0;
      field0 = reader.ReadByte() != 0;
      return new X {
        X = field0,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseX, new() {
      bool field0;
      field0 = reader.ReadByte() != 0;
      return new T {
        X = field0,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  public abstract class BaseW<T0, T1> where T0: BaseD where T1: BaseX {
    internal readonly T0 _value0;
    internal readonly T1 _value1;
    private readonly byte _discriminator;

    protected BaseW(WUnion<T0, T1> input) {
        _discriminator = input.Discriminator;
        switch (_discriminator) {
          case 1: _value0 = input.AsBaseD; break;
          case 2: _value1 = input.AsBaseX; break;
          default: throw new BebopRuntimeException();
        }
    }

    public object Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        _ => throw new BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    public bool IsBaseD => _discriminator is 1;
    public T0 AsBaseD => _discriminator is 1 ? _value0 : throw new NotImplementedException($"Cannot return as BaseD as result is T0");

    public bool IsBaseX => _discriminator is 2;
    public T1 AsBaseX => _discriminator is 2 ? _value1 : throw new NotImplementedException($"Cannot return as BaseX as result is T1");

    public void Switch(Action<T0> f0, Action<T1> f1) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        throw new BebopRuntimeException();
    }

    public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        _ => throw new BebopRuntimeException()
    };

    private bool Equals(BaseW<T0, T1> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        if (ReferenceEquals(this, other)) {
          return true;
        }
        return other is BaseW<T0, T1> o && Equals(o);
    }

    public static bool operator ==(BaseW<T0, T1> left, BaseW<T0, T1> right) => Equals(left, right);
    public static bool operator !=(BaseW<T0, T1> left, BaseW<T0, T1> right) => !Equals(left, right);
    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Union)]
  public abstract class BaseW : BaseW<BaseD, BaseX> {
    protected BaseW(WUnion<BaseD, BaseX> _) : base(_) { }
  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Union)]
  public sealed class W : BaseW {

    private W(WUnion<BaseD, BaseX> _) : base(_) { }

    public static implicit operator W(BaseD _) => new (_);
    public static W FromBaseD(BaseD input) => new (input);

    public static implicit operator W(BaseX _) => new (_);
    public static W FromBaseX(BaseX input) => new (input);

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseW record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      writer.WriteByte(record.Discriminator);
      var start = writer.Length;
      switch (record.Discriminator) {
        case 1: Bebop.Codegen.D.EncodeInto(record.AsBaseD, ref writer); break;
        case 2: Bebop.Codegen.X.EncodeInto(record.AsBaseX, ref writer); break;
      }
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static W DecodeFrom(ref BebopReader reader) {

      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      switch (reader.ReadByte()) {
        case 1:
            return Bebop.Codegen.D.DecodeFrom(ref reader);
        case 2:
            return Bebop.Codegen.X.DecodeFrom(ref reader);
        default:
            reader.Position = end;
            return null;
        }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseW record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseW record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static W Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static W Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static W Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static W Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static W Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  public readonly struct WUnion<T0, T1> where T0: BaseD where T1: BaseX {

    internal readonly T0 _value0;
    internal readonly T1 _value1;
    private readonly byte _discriminator;

    private WUnion(byte discriminator, T0 value0 = default, T1 value1 = default) {
        _discriminator = discriminator;
        _value0 = value0;
        _value1 = value1;
    }

    public object Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        _ => throw new BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    public bool IsBaseD => _discriminator is 1;
    public T0 AsBaseD => _discriminator is 1 ? _value0 : throw new NotImplementedException($"Cannot return as BaseD as result is T0");

    public bool IsBaseX => _discriminator is 2;
    public T1 AsBaseX => _discriminator is 2 ? _value1 : throw new NotImplementedException($"Cannot return as BaseX as result is T1");

    public static implicit operator WUnion<T0, T1>(T0 t) => new  WUnion<T0, T1>(1, value0: t);
    public static WUnion<T0, T1> FromBaseD(T0 input) => input;

    public static implicit operator WUnion<T0, T1>(T1 t) => new  WUnion<T0, T1>(2, value1: t);
    public static WUnion<T0, T1> FromBaseX(T1 input) => input;


    public void Switch(Action<T0> f0, Action<T1> f1) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        throw new BebopRuntimeException();
    }

    public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        _ => throw new BebopRuntimeException()
    };

    private bool Equals(BaseW<T0, T1> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        return other is BaseW<T0, T1> o && Equals(o);
    }

    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

  }

  /// <summary>
  /// This union is so documented!
  /// </summary>
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  public abstract class BaseU<T0, T1, T2, T3> where T0: BaseA where T1: BaseB where T2: BaseC where T3: BaseW {
    public const uint OpCode = 0x68616579;
    internal readonly T0 _value0;
    internal readonly T1 _value1;
    internal readonly T2 _value2;
    internal readonly T3 _value3;
    private readonly byte _discriminator;

    protected BaseU(UUnion<T0, T1, T2, T3> input) {
        _discriminator = input.Discriminator;
        switch (_discriminator) {
          case 1: _value0 = input.AsBaseA; break;
          case 2: _value1 = input.AsBaseB; break;
          case 3: _value2 = input.AsBaseC; break;
          case 4: _value3 = input.AsBaseW; break;
          default: throw new BebopRuntimeException();
        }
    }

    public object Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        3 => _value2,
        4 => _value3,
        _ => throw new BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    public bool IsBaseA => _discriminator is 1;
    public T0 AsBaseA => _discriminator is 1 ? _value0 : throw new NotImplementedException($"Cannot return as BaseA as result is T0");

    public bool IsBaseB => _discriminator is 2;
    public T1 AsBaseB => _discriminator is 2 ? _value1 : throw new NotImplementedException($"Cannot return as BaseB as result is T1");

    public bool IsBaseC => _discriminator is 3;
    public T2 AsBaseC => _discriminator is 3 ? _value2 : throw new NotImplementedException($"Cannot return as BaseC as result is T2");

    public bool IsBaseW => _discriminator is 4;
    public T3 AsBaseW => _discriminator is 4 ? _value3 : throw new NotImplementedException($"Cannot return as BaseW as result is T3");

    public void Switch(Action<T0> f0, Action<T1> f1, Action<T2> f2, Action<T3> f3) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        if (_discriminator is 3 && f2 is not null) {
          f2(_value2);
          return;
        }
        if (_discriminator is 4 && f3 is not null) {
          f3(_value3);
          return;
        }
        throw new BebopRuntimeException();
    }

    public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1, Func<T2, TResult> f2, Func<T3, TResult> f3) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        3 when f2 is not null => f2(_value2),
        4 when f3 is not null => f3(_value3),
        _ => throw new BebopRuntimeException()
    };

    private bool Equals(BaseU<T0, T1, T2, T3> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        3 => Equals(_value2, other._value2),
        4 => Equals(_value3, other._value3),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        if (ReferenceEquals(this, other)) {
          return true;
        }
        return other is BaseU<T0, T1, T2, T3> o && Equals(o);
    }

    public static bool operator ==(BaseU<T0, T1, T2, T3> left, BaseU<T0, T1, T2, T3> right) => Equals(left, right);
    public static bool operator !=(BaseU<T0, T1, T2, T3> left, BaseU<T0, T1, T2, T3> right) => !Equals(left, right);
    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        3 => _value2?.GetHashCode() ?? 0,
        4 => _value3?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Union)]
  public abstract class BaseU : BaseU<BaseA, BaseB, BaseC, BaseW> {
    protected BaseU(UUnion<BaseA, BaseB, BaseC, BaseW> _) : base(_) { }
  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Union)]
  public sealed class U : BaseU {

    private U(UUnion<BaseA, BaseB, BaseC, BaseW> _) : base(_) { }

    public static implicit operator U(BaseA _) => new (_);
    public static U FromBaseA(BaseA input) => new (input);

    public static implicit operator U(BaseB _) => new (_);
    public static U FromBaseB(BaseB input) => new (input);

    public static implicit operator U(BaseC _) => new (_);
    public static U FromBaseC(BaseC input) => new (input);

    public static implicit operator U(BaseW _) => new (_);
    public static U FromBaseW(BaseW input) => new (input);

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseU record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      writer.WriteByte(record.Discriminator);
      var start = writer.Length;
      switch (record.Discriminator) {
        case 1: Bebop.Codegen.A.EncodeInto(record.AsBaseA, ref writer); break;
        case 2: Bebop.Codegen.B.EncodeInto(record.AsBaseB, ref writer); break;
        case 3: Bebop.Codegen.C.EncodeInto(record.AsBaseC, ref writer); break;
        case 4: Bebop.Codegen.W.EncodeInto(record.AsBaseW, ref writer); break;
      }
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static U DecodeFrom(ref BebopReader reader) {

      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      switch (reader.ReadByte()) {
        case 1:
            return Bebop.Codegen.A.DecodeFrom(ref reader);
        case 2:
            return Bebop.Codegen.B.DecodeFrom(ref reader);
        case 3:
            return Bebop.Codegen.C.DecodeFrom(ref reader);
        case 4:
            return Bebop.Codegen.W.DecodeFrom(ref reader);
        default:
            reader.Position = end;
            return null;
        }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseU record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseU record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static U Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static U Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static U Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static U Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static U Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  public readonly struct UUnion<T0, T1, T2, T3> where T0: BaseA where T1: BaseB where T2: BaseC where T3: BaseW {

    internal readonly T0 _value0;
    internal readonly T1 _value1;
    internal readonly T2 _value2;
    internal readonly T3 _value3;
    private readonly byte _discriminator;

    private UUnion(byte discriminator, T0 value0 = default, T1 value1 = default, T2 value2 = default, T3 value3 = default) {
        _discriminator = discriminator;
        _value0 = value0;
        _value1 = value1;
        _value2 = value2;
        _value3 = value3;
    }

    public object Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        3 => _value2,
        4 => _value3,
        _ => throw new BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    public bool IsBaseA => _discriminator is 1;
    public T0 AsBaseA => _discriminator is 1 ? _value0 : throw new NotImplementedException($"Cannot return as BaseA as result is T0");

    public bool IsBaseB => _discriminator is 2;
    public T1 AsBaseB => _discriminator is 2 ? _value1 : throw new NotImplementedException($"Cannot return as BaseB as result is T1");

    public bool IsBaseC => _discriminator is 3;
    public T2 AsBaseC => _discriminator is 3 ? _value2 : throw new NotImplementedException($"Cannot return as BaseC as result is T2");

    public bool IsBaseW => _discriminator is 4;
    public T3 AsBaseW => _discriminator is 4 ? _value3 : throw new NotImplementedException($"Cannot return as BaseW as result is T3");

    public static implicit operator UUnion<T0, T1, T2, T3>(T0 t) => new  UUnion<T0, T1, T2, T3>(1, value0: t);
    public static UUnion<T0, T1, T2, T3> FromBaseA(T0 input) => input;

    public static implicit operator UUnion<T0, T1, T2, T3>(T1 t) => new  UUnion<T0, T1, T2, T3>(2, value1: t);
    public static UUnion<T0, T1, T2, T3> FromBaseB(T1 input) => input;

    public static implicit operator UUnion<T0, T1, T2, T3>(T2 t) => new  UUnion<T0, T1, T2, T3>(3, value2: t);
    public static UUnion<T0, T1, T2, T3> FromBaseC(T2 input) => input;

    public static implicit operator UUnion<T0, T1, T2, T3>(T3 t) => new  UUnion<T0, T1, T2, T3>(4, value3: t);
    public static UUnion<T0, T1, T2, T3> FromBaseW(T3 input) => input;


    public void Switch(Action<T0> f0, Action<T1> f1, Action<T2> f2, Action<T3> f3) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        if (_discriminator is 3 && f2 is not null) {
          f2(_value2);
          return;
        }
        if (_discriminator is 4 && f3 is not null) {
          f3(_value3);
          return;
        }
        throw new BebopRuntimeException();
    }

    public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1, Func<T2, TResult> f2, Func<T3, TResult> f3) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        3 when f2 is not null => f2(_value2),
        4 when f3 is not null => f3(_value3),
        _ => throw new BebopRuntimeException()
    };

    private bool Equals(BaseU<T0, T1, T2, T3> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        3 => Equals(_value2, other._value2),
        4 => Equals(_value3, other._value3),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        return other is BaseU<T0, T1, T2, T3> o && Equals(o);
    }

    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        3 => _value2?.GetHashCode() ?? 0,
        4 => _value3?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseCons : System.IEquatable<BaseCons> {
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public uint Head { get; set; }
    [System.Diagnostics.CodeAnalysis.NotNull, System.Diagnostics.CodeAnalysis.DisallowNull]
    public BaseList Tail { get; set; }

    public bool Equals(BaseCons other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return Head == other.Head && Tail == other.Tail;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseCons baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= Head.GetHashCode();
      hash ^= Tail.GetHashCode();
      return hash;
    }

    public static bool operator ==(BaseCons left, BaseCons right) => Equals(left, right);
    public static bool operator !=(BaseCons left, BaseCons  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class Cons : BaseCons {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseCons record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseCons record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseCons record, ref BebopWriter writer) {
      writer.WriteUInt32(record.Head);
      Bebop.Codegen.List.EncodeInto(record.Tail, ref writer);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseCons, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Cons Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseCons, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Cons Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseCons, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Cons Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseCons, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Cons Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseCons, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Cons Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Cons DecodeFrom(ref BebopReader reader) {

      uint field0;
      field0 = reader.ReadUInt32();
      BaseList field1;
      field1 = Bebop.Codegen.List.DecodeFrom(ref reader);
      return new Cons {
        Head = field0,
        Tail = field1,
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseCons, new() {
      uint field0;
      field0 = reader.ReadUInt32();
      BaseList field1;
      field1 = Bebop.Codegen.List.DecodeFrom(ref reader);
      return new T {
        Head = field0,
        Tail = field1,
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public abstract class BaseNil : System.IEquatable<BaseNil> {

    public bool Equals(BaseNil other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return true;
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not BaseNil baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    public static bool operator ==(BaseNil left, BaseNil right) => Equals(left, right);
    public static bool operator !=(BaseNil left, BaseNil  right) => !Equals(left, right);

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Struct)]
  public sealed class Nil : BaseNil {

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseNil record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseNil record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseNil record, ref BebopWriter writer) {

    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(byte[] record) where T : BaseNil, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Nil Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlySpan<byte> record) where T : BaseNil, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Nil Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ReadOnlyMemory<byte> record) where T : BaseNil, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Nil Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(System.ArraySegment<byte> record) where T : BaseNil, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Nil Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static T DecodeAs<T>(ImmutableArray<byte> record) where T : BaseNil, new() {
      var reader = BebopReader.From(record);
      return DecodeFrom<T>(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static Nil Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }


    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static Nil DecodeFrom(ref BebopReader reader) {

      return new Nil {
      };
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static T DecodeFrom<T>(ref BebopReader reader) where T: BaseNil, new() {
      return new T {
      };
    }

  }

  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  public abstract class BaseList<T0, T1> where T0: BaseCons where T1: BaseNil {
    internal readonly T0 _value0;
    internal readonly T1 _value1;
    private readonly byte _discriminator;

    protected BaseList(ListUnion<T0, T1> input) {
        _discriminator = input.Discriminator;
        switch (_discriminator) {
          case 1: _value0 = input.AsBaseCons; break;
          case 2: _value1 = input.AsBaseNil; break;
          default: throw new BebopRuntimeException();
        }
    }

    public object Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        _ => throw new BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    public bool IsBaseCons => _discriminator is 1;
    public T0 AsBaseCons => _discriminator is 1 ? _value0 : throw new NotImplementedException($"Cannot return as BaseCons as result is T0");

    public bool IsBaseNil => _discriminator is 2;
    public T1 AsBaseNil => _discriminator is 2 ? _value1 : throw new NotImplementedException($"Cannot return as BaseNil as result is T1");

    public void Switch(Action<T0> f0, Action<T1> f1) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        throw new BebopRuntimeException();
    }

    public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        _ => throw new BebopRuntimeException()
    };

    private bool Equals(BaseList<T0, T1> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        if (ReferenceEquals(this, other)) {
          return true;
        }
        return other is BaseList<T0, T1> o && Equals(o);
    }

    public static bool operator ==(BaseList<T0, T1> left, BaseList<T0, T1> right) => Equals(left, right);
    public static bool operator !=(BaseList<T0, T1> left, BaseList<T0, T1> right) => !Equals(left, right);
    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Union)]
  public abstract class BaseList : BaseList<BaseCons, BaseNil> {
    protected BaseList(ListUnion<BaseCons, BaseNil> _) : base(_) { }
  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  [BebopRecord(BebopKind.Union)]
  public sealed class List : BaseList {

    private List(ListUnion<BaseCons, BaseNil> _) : base(_) { }

    public static implicit operator List(BaseCons _) => new (_);
    public static List FromBaseCons(BaseCons input) => new (input);

    public static implicit operator List(BaseNil _) => new (_);
    public static List FromBaseNil(BaseNil input) => new (input);

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static void EncodeInto(BaseList record, ref BebopWriter writer) {
      var pos = writer.ReserveRecordLength();
      writer.WriteByte(record.Discriminator);
      var start = writer.Length;
      switch (record.Discriminator) {
        case 1: Bebop.Codegen.Cons.EncodeInto(record.AsBaseCons, ref writer); break;
        case 2: Bebop.Codegen.Nil.EncodeInto(record.AsBaseNil, ref writer); break;
      }
      var end = writer.Length;
      writer.FillRecordLength(pos, unchecked((uint) unchecked(end - start)));
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    internal static List DecodeFrom(ref BebopReader reader) {

      var length = reader.ReadRecordLength();
      var end = unchecked((int) (reader.Position + length));
      switch (reader.ReadByte()) {
        case 1:
            return Bebop.Codegen.Cons.DecodeFrom(ref reader);
        case 2:
            return Bebop.Codegen.Nil.DecodeFrom(ref reader);
        default:
            reader.Position = end;
            return null;
        }
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static byte[] Encode(BaseList record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public byte[] Encode() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static ImmutableArray<byte> EncodeAsImmutable(BaseList record) {
      var writer = BebopWriter.Create();
      EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public ImmutableArray<byte> EncodeAsImmutable() {
      var writer = BebopWriter.Create();
      EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static List Decode(byte[] record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static List Decode(System.ReadOnlySpan<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static List Decode(System.ReadOnlyMemory<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static List Decode(System.ArraySegment<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

    [System.Runtime.CompilerServices.MethodImpl(BebopConstants.HotPath)]
    public static List Decode(ImmutableArray<byte> record) {
      var reader = BebopReader.From(record);
      return DecodeFrom(ref reader);
    }

  }

  /// <inheritdoc />
  [System.CodeDom.Compiler.GeneratedCode("bebopc", "0.0.1-20210208-0337")]
  public readonly struct ListUnion<T0, T1> where T0: BaseCons where T1: BaseNil {

    internal readonly T0 _value0;
    internal readonly T1 _value1;
    private readonly byte _discriminator;

    private ListUnion(byte discriminator, T0 value0 = default, T1 value1 = default) {
        _discriminator = discriminator;
        _value0 = value0;
        _value1 = value1;
    }

    public object Value => _discriminator switch {
        1 => _value0,
        2 => _value1,
        _ => throw new BebopRuntimeException()
    };

    public byte Discriminator => _discriminator;

    public bool IsBaseCons => _discriminator is 1;
    public T0 AsBaseCons => _discriminator is 1 ? _value0 : throw new NotImplementedException($"Cannot return as BaseCons as result is T0");

    public bool IsBaseNil => _discriminator is 2;
    public T1 AsBaseNil => _discriminator is 2 ? _value1 : throw new NotImplementedException($"Cannot return as BaseNil as result is T1");

    public static implicit operator ListUnion<T0, T1>(T0 t) => new  ListUnion<T0, T1>(1, value0: t);
    public static ListUnion<T0, T1> FromBaseCons(T0 input) => input;

    public static implicit operator ListUnion<T0, T1>(T1 t) => new  ListUnion<T0, T1>(2, value1: t);
    public static ListUnion<T0, T1> FromBaseNil(T1 input) => input;


    public void Switch(Action<T0> f0, Action<T1> f1) {
        if (_discriminator is 1 && f0 is not null) {
          f0(_value0);
          return;
        }
        if (_discriminator is 2 && f1 is not null) {
          f1(_value1);
          return;
        }
        throw new BebopRuntimeException();
    }

    public TResult Match<TResult>(Func<T0, TResult> f0, Func<T1, TResult> f1) => _discriminator switch {
        1 when f0 is not null => f0(_value0),
        2 when f1 is not null => f1(_value1),
        _ => throw new BebopRuntimeException()
    };

    private bool Equals(BaseList<T0, T1> other) => _discriminator == other.Discriminator && _discriminator switch {
        1 => Equals(_value0, other._value0),
        2 => Equals(_value1, other._value1),
        _ => false
    };

    public override bool Equals(object other) {
        if (ReferenceEquals(null, other)) {
          return false;
        }
        return other is BaseList<T0, T1> o && Equals(o);
    }

    public override int GetHashCode() => (_discriminator switch {
        1 => _value0?.GetHashCode() ?? 0,
        2 => _value1?.GetHashCode() ?? 0,
        _ => 0
    } * 397) ^ _discriminator;

  }

}
